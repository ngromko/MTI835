#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

struct Particle {
    vec4 pos;
    vec4 color;
    vec4 color1;
    /*float alpha;
    float size;
    float rotation;
    uint type;*/
    // Attributes not used in shader
    vec4 vel;
};

struct BurningPoint
{
    vec4 pos;
    vec4 basePos;
    uint neighs[10];
    uint nCount;
    uint state;
};
layout(std430, binding = 0) buffer Bumbo
{
   Particle particles[ ];
};
// Binding 1 : Position storage buffer
layout(std430,binding = 1) buffer Burning
{
   BurningPoint bPoints[];
};

layout (local_size_x = 512) in;

layout (binding = 2) uniform UBO
{
        //float deltaT;
        vec4 delta;
        vec4 click;
        int pCount;
        int bCount;
        int bCount3;
} ubo;

void main() 
{
    // Current SSBO index
    uint index = gl_GlobalInvocationID.x;
	// Don't try to write beyond particle count
        // Faire rien si le point ne brule pas
    if (index >= ubo.bCount /*&& bPoints[index].state!=1*/)
		return;	
    BurningPoint me = bPoints[index];
    
    uint ncount = me.nCount&15;

    //uint pIndex =  me.state;
    if(me.state>=1000){
        for(int i=0;i<ncount;i++){
            if(bPoints[me.neighs[i]].state<=1000){
                bPoints[me.neighs[i]].state++;
            }
        }
        me.state++;
        if(me.state>=3100.0f){
            particles[index].pos=bPoints[index].pos;
            me.state=1001;
        }
        bPoints[index].state=me.state;
    }
    
    /*
    pIndex++;
    if(pIndex>=6)
        pIndex=0;
    me.partIndex=pIndex;*/
    
    //float particleTimer = ubo.deltaT * 0.45f;
    /*particles[index].alpha += particleTimer * 2.5f;
    particles[index].size -= particleTimer * 0.5f;
    particles[index+8000].pos.y = ubo.bCount;*/
}

